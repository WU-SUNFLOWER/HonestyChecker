#include <stdio.h>
#include <math.h>
#include <stdbool.h>

typedef struct {
    double x;
    double y;
} Point;

typedef struct {
    double x;
    double y;
    double magnitude;
} Vector;

Vector createVector(Point a, Point b) {
    Vector v;
    v.x = b.x - a.x;
    v.y = b.y - a.y;
    v.magnitude = sqrt(v.x * v.x + v.y * v.y);
    return v;
}

// 计算余弦值
double calculateCosine(Vector v1, Vector v2, Vector v3) {
    double len1 = v1.magnitude;
    double len2 = v2.magnitude;
    double len3 = v3.magnitude;
    return (len1 * len1 + len2 * len2 - len3 * len3) / (2 * len1 * len2);
}

// 判断是否平行
bool checkParallel(Vector v1, Vector v2) {
    if (v1.x == 0 || v2.x == 0) {
        return v1.x == 0 && v2.x == 0;
    } else if (v1.y == 0 || v2.y == 0) {
        return v1.y == 0 && v2.y == 0;
    } else {
        return (v1.x / v2.x) == (v1.y / v2.y);
    }
}

// 获取最大值
double getMax(double a, double b, double c) {
    return fmax(fmax(a, b), c);
}

// 计算最小覆盖圆半径
double calculateMinRadius(Point p1, Point p2, Point p3) {
    Vector v1 = createVector(p1, p2);
    Vector v2 = createVector(p1, p3);
    Vector v3 = createVector(p2, p3);
    //判断直角或钝角三角形，或共线情况
    if (checkParallel(v1, v2) || calculateCosine(v1, v2, v3) <= 0 ||
        calculateCosine(v1, v3, v2) <= 0 || calculateCosine(v2, v3, v1) <= 0) {
        return getMax(v1.magnitude, v2.magnitude, v3.magnitude) / 2;
    }
    // 计算外接圆半径
    double len1 = v1.magnitude;
    double len2 = v2.magnitude;
    double len3 = v3.magnitude;
    double semiPerimeter = (len1 + len2 + len3) / 2;
    double area = sqrt(semiPerimeter * (semiPerimeter - len1) * (semiPerimeter - len2) * (semiPerimeter - len3));
    return len1 * len2 * len3 / (4 * area);
}

int main() {
    int totalPoints;
    Point points[100];
    scanf("%d", &totalPoints);
    for (int i = 0; i < totalPoints; i++) {
        scanf("%lf,%lf", &points[i].x, &points[i].y);
    }
    // 遍历所有三点组合情况
    double minRadius = 0;
    for (int i = 0; i < totalPoints; i++) {
        for (int j = i + 1; j < totalPoints; j++) {
            for (int k = j + 1; k < totalPoints; k++) {
                Point p1 = points[i];
                Point p2 = points[j];
                Point p3 = points[k];
                double radius = calculateMinRadius(p1, p2, p3);
                minRadius = fmax(minRadius, radius);
            }
        }
    }
    printf("以上%d个点的覆盖圆的最小半径为%.4lf\n", totalPoints, minRadius);
}